[dotenv@17.3.1] injecting env (9) from .env -- tip: ‚öôÔ∏è  load multiple .env files with { path: ['.env.local', '.env'] }
[dotenv@17.3.1] injecting env (0) from .env -- tip: ‚öôÔ∏è  load multiple .env files with { path: ['.env.local', '.env'] }
(node:12374) [DEP0169] DeprecationWarning: `url.parse()` behavior is not standardized and prone to errors that have security implications. Use the WHATWG URL API instead. CVEs are not issued for `url.parse()` vulnerabilities.
(Use `node --trace-deprecation ...` to show where the warning was created)
Executing (default): SELECT 1+1 AS result
Database connection has been established successfully.
Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'doc_types'
Executing (default): SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = 'doc_types' AND c.table_schema = 'public'
Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'doc_types' AND tc.table_catalog = 'db_repository'
Executing (default): ALTER TABLE "doc_types" ALTER COLUMN "name" SET NOT NULL;ALTER TABLE "doc_types" ALTER COLUMN "name" DROP DEFAULT;ALTER TABLE "doc_types" ALTER COLUMN "name" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "doc_types" ALTER COLUMN "slug" SET NOT NULL;ALTER TABLE "doc_types" ALTER COLUMN "slug" DROP DEFAULT;ALTER TABLE "doc_types"  ADD UNIQUE ("slug");ALTER TABLE "doc_types" ALTER COLUMN "slug" TYPE VARCHAR(255)  ;
Executing (default): ALTER TABLE "doc_types" ALTER COLUMN "description" DROP NOT NULL;ALTER TABLE "doc_types" ALTER COLUMN "description" DROP DEFAULT;ALTER TABLE "doc_types" ALTER COLUMN "description" TYPE TEXT;
Executing (default): ALTER TABLE "doc_types" ALTER COLUMN "is_active" DROP NOT NULL;ALTER TABLE "doc_types" ALTER COLUMN "is_active" SET DEFAULT true;ALTER TABLE "doc_types" ALTER COLUMN "is_active" TYPE BOOLEAN;
Executing (default): ALTER TABLE "doc_types" ALTER COLUMN "created_at" SET NOT NULL;ALTER TABLE "doc_types" ALTER COLUMN "created_at" DROP DEFAULT;ALTER TABLE "doc_types" ALTER COLUMN "created_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): ALTER TABLE "doc_types" ALTER COLUMN "updated_at" SET NOT NULL;ALTER TABLE "doc_types" ALTER COLUMN "updated_at" DROP DEFAULT;ALTER TABLE "doc_types" ALTER COLUMN "updated_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'doc_types' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'program_studi'
Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_program_studi_status' GROUP BY 1
Executing (default): SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = 'program_studi' AND c.table_schema = 'public'
Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'program_studi' AND tc.table_catalog = 'db_repository'
Executing (default): ALTER TABLE "program_studi" ALTER COLUMN "name" SET NOT NULL;ALTER TABLE "program_studi" ALTER COLUMN "name" DROP DEFAULT;ALTER TABLE "program_studi" ALTER COLUMN "name" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "program_studi" ALTER COLUMN "code" SET NOT NULL;ALTER TABLE "program_studi" ALTER COLUMN "code" DROP DEFAULT;ALTER TABLE "program_studi"  ADD UNIQUE ("code");ALTER TABLE "program_studi" ALTER COLUMN "code" TYPE VARCHAR(255)  ;
Executing (default): ALTER TABLE "program_studi" ALTER COLUMN "head" DROP NOT NULL;ALTER TABLE "program_studi" ALTER COLUMN "head" DROP DEFAULT;ALTER TABLE "program_studi" ALTER COLUMN "head" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "program_studi" ALTER COLUMN "status" DROP NOT NULL;ALTER TABLE "program_studi" ALTER COLUMN "status" SET DEFAULT 'Aktif';DO 'BEGIN CREATE TYPE "public"."enum_program_studi_status" AS ENUM(''Aktif'', ''Tidak Aktif''); EXCEPTION WHEN duplicate_object THEN null; END';ALTER TABLE "program_studi" ALTER COLUMN "status" TYPE "public"."enum_program_studi_status" USING ("status"::"public"."enum_program_studi_status");
Executing (default): ALTER TABLE "program_studi" ALTER COLUMN "created_at" SET NOT NULL;ALTER TABLE "program_studi" ALTER COLUMN "created_at" DROP DEFAULT;ALTER TABLE "program_studi" ALTER COLUMN "created_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): ALTER TABLE "program_studi" ALTER COLUMN "updated_at" SET NOT NULL;ALTER TABLE "program_studi" ALTER COLUMN "updated_at" DROP DEFAULT;ALTER TABLE "program_studi" ALTER COLUMN "updated_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'program_studi' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'roles'
Executing (default): SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = 'roles' AND c.table_schema = 'public'
Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'roles' AND tc.table_catalog = 'db_repository'
Executing (default): ALTER TABLE "roles" ALTER COLUMN "name" SET NOT NULL;ALTER TABLE "roles" ALTER COLUMN "name" DROP DEFAULT;ALTER TABLE "roles"  ADD UNIQUE ("name");ALTER TABLE "roles" ALTER COLUMN "name" TYPE VARCHAR(255)  ;
Executing (default): ALTER TABLE "roles" ALTER COLUMN "slug" SET NOT NULL;ALTER TABLE "roles" ALTER COLUMN "slug" DROP DEFAULT;ALTER TABLE "roles"  ADD UNIQUE ("slug");ALTER TABLE "roles" ALTER COLUMN "slug" TYPE VARCHAR(255)  ;
Executing (default): ALTER TABLE "roles" ALTER COLUMN "created_at" SET NOT NULL;ALTER TABLE "roles" ALTER COLUMN "created_at" DROP DEFAULT;ALTER TABLE "roles" ALTER COLUMN "created_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): ALTER TABLE "roles" ALTER COLUMN "updated_at" SET NOT NULL;ALTER TABLE "roles" ALTER COLUMN "updated_at" DROP DEFAULT;ALTER TABLE "roles" ALTER COLUMN "updated_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'roles' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users'
Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_users_status' GROUP BY 1
Executing (default): SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = 'users' AND c.table_schema = 'public'
Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'db_repository'
Executing (default): ALTER TABLE "users" ALTER COLUMN "name" SET NOT NULL;ALTER TABLE "users" ALTER COLUMN "name" DROP DEFAULT;ALTER TABLE "users" ALTER COLUMN "name" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "users" ALTER COLUMN "email" SET NOT NULL;ALTER TABLE "users" ALTER COLUMN "email" DROP DEFAULT;ALTER TABLE "users"  ADD UNIQUE ("email");ALTER TABLE "users" ALTER COLUMN "email" TYPE VARCHAR(255)  ;
Executing (default): ALTER TABLE "users" ALTER COLUMN "password" SET NOT NULL;ALTER TABLE "users" ALTER COLUMN "password" DROP DEFAULT;ALTER TABLE "users" ALTER COLUMN "password" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "users" ALTER COLUMN "nip" DROP NOT NULL;ALTER TABLE "users" ALTER COLUMN "nip" DROP DEFAULT;ALTER TABLE "users" ALTER COLUMN "nip" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "users" DROP CONSTRAINT "users_role_id_fkey"
Executing (default): ALTER TABLE "users" ALTER COLUMN "role_id" SET NOT NULL;ALTER TABLE "users"  ADD FOREIGN KEY ("role_id") REFERENCES "roles" ("id") ON DELETE CASCADE ON UPDATE CASCADE;
Executing (default): ALTER TABLE "users" DROP CONSTRAINT "users_prodi_id_fkey"
Executing (default): ALTER TABLE "users"  ADD FOREIGN KEY ("prodi_id") REFERENCES "program_studi" ("id") ON DELETE SET NULL ON UPDATE CASCADE;
Executing (default): ALTER TABLE "users" ALTER COLUMN "status" DROP NOT NULL;ALTER TABLE "users" ALTER COLUMN "status" SET DEFAULT 'active';DO 'BEGIN CREATE TYPE "public"."enum_users_status" AS ENUM(''active'', ''inactive''); EXCEPTION WHEN duplicate_object THEN null; END';ALTER TABLE "users" ALTER COLUMN "status" TYPE "public"."enum_users_status" USING ("status"::"public"."enum_users_status");
Executing (default): ALTER TABLE "users" ALTER COLUMN "created_at" SET NOT NULL;ALTER TABLE "users" ALTER COLUMN "created_at" DROP DEFAULT;ALTER TABLE "users" ALTER COLUMN "created_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): ALTER TABLE "users" ALTER COLUMN "updated_at" SET NOT NULL;ALTER TABLE "users" ALTER COLUMN "updated_at" DROP DEFAULT;ALTER TABLE "users" ALTER COLUMN "updated_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'repositories'
Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_repositories_status' GROUP BY 1
Executing (default): SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = 'repositories' AND c.table_schema = 'public'
Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'repositories' AND tc.table_catalog = 'db_repository'
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "title" SET NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "title" DROP DEFAULT;ALTER TABLE "repositories" ALTER COLUMN "title" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "abstract" DROP NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "abstract" DROP DEFAULT;ALTER TABLE "repositories" ALTER COLUMN "abstract" TYPE TEXT;
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "author" SET NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "author" DROP DEFAULT;ALTER TABLE "repositories" ALTER COLUMN "author" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "year" DROP NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "year" DROP DEFAULT;ALTER TABLE "repositories" ALTER COLUMN "year" TYPE INTEGER;
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "file_path" SET NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "file_path" DROP DEFAULT;ALTER TABLE "repositories" ALTER COLUMN "file_path" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "file_name" SET NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "file_name" DROP DEFAULT;ALTER TABLE "repositories" ALTER COLUMN "file_name" TYPE VARCHAR(255);
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "file_size" DROP NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "file_size" DROP DEFAULT;ALTER TABLE "repositories" ALTER COLUMN "file_size" TYPE INTEGER;
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "status" DROP NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "status" SET DEFAULT 'draft';DO 'BEGIN CREATE TYPE "public"."enum_repositories_status" AS ENUM(''draft'', ''published'', ''archived''); EXCEPTION WHEN duplicate_object THEN null; END';ALTER TABLE "repositories" ALTER COLUMN "status" TYPE "public"."enum_repositories_status" USING ("status"::"public"."enum_repositories_status");
Executing (default): ALTER TABLE "repositories" DROP CONSTRAINT "repositories_prodi_id_fkey"
Executing (default): ALTER TABLE "repositories"  ADD FOREIGN KEY ("prodi_id") REFERENCES "program_studi" ("id") ON DELETE SET NULL ON UPDATE CASCADE;
Executing (default): ALTER TABLE "repositories" DROP CONSTRAINT "repositories_doc_type_id_fkey"
Executing (default): ALTER TABLE "repositories"  ADD FOREIGN KEY ("doc_type_id") REFERENCES "doc_types" ("id") ON DELETE SET NULL ON UPDATE CASCADE;
Executing (default): ALTER TABLE "repositories" DROP CONSTRAINT "repositories_uploaded_by_fkey"
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "uploaded_by" SET NOT NULL;ALTER TABLE "repositories"  ADD FOREIGN KEY ("uploaded_by") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE CASCADE;
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "created_at" SET NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "created_at" DROP DEFAULT;ALTER TABLE "repositories" ALTER COLUMN "created_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): ALTER TABLE "repositories" ALTER COLUMN "updated_at" SET NOT NULL;ALTER TABLE "repositories" ALTER COLUMN "updated_at" DROP DEFAULT;ALTER TABLE "repositories" ALTER COLUMN "updated_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'repositories' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'download_logs'
Executing (default): SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = 'download_logs' AND c.table_schema = 'public'
Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'download_logs' AND tc.table_catalog = 'db_repository'
Executing (default): ALTER TABLE "download_logs" DROP CONSTRAINT "download_logs_repository_id_fkey"
Executing (default): ALTER TABLE "download_logs" ALTER COLUMN "repository_id" SET NOT NULL;ALTER TABLE "download_logs"  ADD FOREIGN KEY ("repository_id") REFERENCES "repositories" ("id") ON DELETE NO ACTION ON UPDATE CASCADE;
Executing (default): ALTER TABLE "download_logs" DROP CONSTRAINT "download_logs_user_id_fkey"
Executing (default): ALTER TABLE "download_logs" ALTER COLUMN "user_id" SET NOT NULL;ALTER TABLE "download_logs"  ADD FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE CASCADE;
Executing (default): ALTER TABLE "download_logs" ALTER COLUMN "downloaded_at" DROP NOT NULL;ALTER TABLE "download_logs" ALTER COLUMN "downloaded_at" DROP DEFAULT;ALTER TABLE "download_logs" ALTER COLUMN "downloaded_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'download_logs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'permissions'
Executing (default): SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = 'permissions' AND c.table_schema = 'public'
Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'permissions' AND tc.table_catalog = 'db_repository'
Executing (default): ALTER TABLE "permissions" ALTER COLUMN "name" SET NOT NULL;ALTER TABLE "permissions" ALTER COLUMN "name" DROP DEFAULT;ALTER TABLE "permissions"  ADD UNIQUE ("name");ALTER TABLE "permissions" ALTER COLUMN "name" TYPE VARCHAR(255)  ;
Executing (default): ALTER TABLE "permissions" ALTER COLUMN "description" DROP NOT NULL;ALTER TABLE "permissions" ALTER COLUMN "description" DROP DEFAULT;ALTER TABLE "permissions" ALTER COLUMN "description" TYPE VARCHAR(255);
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'permissions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'role_permissions'
Executing (default): SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = 'role_permissions' AND c.table_schema = 'public'
Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'role_permissions' AND tc.table_catalog = 'db_repository'
Executing (default): ALTER TABLE "role_permissions" ALTER COLUMN "created_at" SET NOT NULL;ALTER TABLE "role_permissions" ALTER COLUMN "created_at" DROP DEFAULT;ALTER TABLE "role_permissions" ALTER COLUMN "created_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): ALTER TABLE "role_permissions" ALTER COLUMN "updated_at" SET NOT NULL;ALTER TABLE "role_permissions" ALTER COLUMN "updated_at" DROP DEFAULT;ALTER TABLE "role_permissions" ALTER COLUMN "updated_at" TYPE TIMESTAMP WITH TIME ZONE;
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'role_permissions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Database synced successfully.
üöÄ Server is running on port 5000
üëâ http://localhost:5000/api/health
